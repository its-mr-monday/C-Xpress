/*
    CXPRESS COMPILER PARSER WRITTEN IN CXPRESS
    CYBER M TECHNOLOGIES 2022
*/
#INCLUDE <std.lib>
#INCLUDE <std.file>
#framework System
#framework System.IO
#framework System.Text
#framework System.Collections
#framework System.Collections.Generic
#framework System.Linq
#framework System.Text.RegularExpressions
#framework System.Threading
#framework System.Threading.Tasks
#framework System.Web

func getParserDir() = str {
    str parser_dir = AppContext.BaseDirectory;
    return parser_dir;
}

func variable_dict() = Dictionary<str, str> {
    Dictionary<str, str> dict;
    dict.Add("str", "string");
    dict.Add("uint32", "UInt32");
    dict.Add("int32", "Int32");
    dict.Add("pointer", "IntPtr");
    dict.Add("datetime", "DateTime");
    return dict;
}

//Dictionary<string, string> format_types = new Dictionary<string, string>();
func return_format_types() = Dictionary<str, str> {
    Dictionary<str, str> format_types();
    format_types.Add("TAB", "   ");
    format_types.Add("SPACE", " ");
    format_types.Add("FUNCTIONAL", "var x = some_func(args); || some_func(args);");
    format_types.Add("OBJECT", "Type name(args);");
    format_types.Add("ARRAY", "var[] x[length];");
    return format_types;
}
//Dictionary<string, string> func_translations = new Dictionary<string, string>();
func return_func_translations() = Dictionary<str, str> {
    Dictionary<str, str> func_translations();
    func_trasnlations.Add("OBJECT", "Type name = new Type(args);");
    func_translations.Add("ARRAY", "var[] x = new var[length];");
    return func_translations;
}

func read_file(str file_name) = str {
    if (fileExists(file_name)) {
        //Use std.file.readFile
        byte[] filedata = readFile(file_name);
        //use std.lib.bytesToStr
        str file = bytesToStr(filedata);
        return file;
    }
    return null;
}

func load_m_files(str[] include_table, str file_path) = str[] {
    str parser = getParserDir();
    str[] files = include_table;
    if (isDir(pathCombine(file_path, "m_files"))) {
        file_path = pathCombine(file_path, "m_files") {
            for (int x = 0;x < files.Length; x++) {
                str file = files[x];
                //Parse the file by removing the #INCLUDE statement
                if (file.Contains("#INCLUDE <")) {
                    file = file.Replace("#INCLUDE <", "");
                    file = file.Replace(">", "");
                    str[] fnames = file.Split(".");
                    str dir = fnames[0];
                    str fname = fnames[1];
                    fname = fname + ".m";
                    fname = Path.Join(parser, "m_files", dir, fname);
                    file[x] = fname;
                }
                else if (file.Contains("#INCLUDE \"")) {
                    file = file.Replace("#INCLUDE \"", "");
                    file = file.Replace("\"", "");
                    str[] fnames = file.Split(".");
                    str dir = fnames[0];
                    str fname = fnames[1];
                    fname = fname + ".m";
                    fname = Path.Join(file_path, dir ,fname);
                    file[x] = fname;
                }
                else {
                    //Could not locate filename
                    file[x] = null;
                }
            }
        }
    }
    return files;
}

func parse_mh_file(str mh_file_path, Dictionary<str, str> function_translations) = Dictionary<str, str> {
    str[] file_lines = readFileLines(mh_file);
    foreach (str line in file_lines) {
        str[] split_line = line.Split(" => ");
        str cs_ver = split_line[1];
        str cx_ver = split_line[0];
        function_translations.Add(cx_ver, cs_ver);
    }
    return function_translations;
}

func load_cx_files(str[] ming_table, str file_path) = str[] {

}



//Parse the .NET framework namespaces from #framework x => using x;
func load_framework_files(str[] framework_table, str file_path) = str[] {
    str[] frameworks = framework_table;
    for (int x = 0; x < frameworks.Length; x++) {
        str file = frameworks[x];
        file.Replace("#framework ", "");
        file = "using " + file + ";";
        frameworks[x] = file;
    }
    return frameworks;
}

//Will parse a file at path and return its C# files path
func parse_file(str filename) = str {
    //First step is to read the file
    str file_data = read_file(filename);
    if (file_data != null) {

    }
    return null;
}

//Parser main to be called by compiler.cx
func parser_main(str[] args) = int {

    if (args[0] == "-h" || args[0] == "--help") {
        print("Usage: cxc.exe <filename> <project name> <project type>");
        print("Example: cxc.exe test.cx test Console");
        return 0;
    }
    if (args.Length < 3) {
        print("Not enough arguments");
        return 0;
    }

}